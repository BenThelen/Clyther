'''
Created on Mar 28, 2010 by GeoSpin Inc
@author: Sean Ross-Ross srossross@geospin.ca
website: www.geospin.ca
'''
from StringIO import StringIO
from clyther.memory import global_array_type, shared_array_type
from clyther.api.cltypes import cltype
import time


#================================================================================#
# Copyright 2009 GeoSpin Inc.                                                    #
#                                                                                # 
# Licensed under the Apache License, Version 2.0 (the "License");                #
# you may not use this file except in compliance with the License.               #
# You may obtain a copy of the License at                                        #
#                                                                                #
#      http://www.apache.org/licenses/LICENSE-2.0                                #
#                                                                                #
# Unless required by applicable law or agreed to in writing, software            #
# distributed under the License is distributed on an "AS IS" BASIS,              #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.       #
# See the License for the specific language governing permissions and            #
# limitations under the License.                                                 #
#================================================================================#

_HEADER_STRING = """
// 
// This File was automatically generated by CLyther
// DO NOT EDIT!
// Created on {ctime} by CLyther
// website: www.geospin.ca
//
//================================================================================//
// Copyright 2009 GeoSpin Inc.                                                    //
//                                                                                // 
// Licensed under the Apache License, Version 2.0 (the "License");                //
// you may not use this file except in compliance with the License.               //
// You may obtain a copy of the License at                                        //
//                                                                                //
//      http://www.apache.org/licenses/LICENSE-2.0                                //
//                                                                                //
// Unless required by applicable law or agreed to in writing, software            //
// distributed under the License is distributed on an "AS IS" BASIS,              //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.       //
// See the License for the specific language governing permissions and            //
// limitations under the License.                                                 //
//================================================================================//
//
//

#ifndef _CLYTHER_CEXPORT_{MODNAME}_
#define _CLYTHER_CEXPORT_{MODNAME}_

#ifdef __APPLE__ // if Mac
#include <OpenCL/opencl.h>
#else
#include <CL/cl.h>
#endif

{header_body}

#endif _CLYTHER_CEXPORT_{MODNAME}_

"""


_CCODE_STRING = """
// 
// This File was automatically generated by CLyther
// DO NOT EDIT!
// Created on {ctime} by CLyther
// website: www.geospin.ca
//
//================================================================================//
// Copyright 2009 GeoSpin Inc.                                                    //
//                                                                                // 
// Licensed under the Apache License, Version 2.0 (the "License");                //
// you may not use this file except in compliance with the License.               //
// You may obtain a copy of the License at                                        //
//                                                                                //
//      http://www.apache.org/licenses/LICENSE-2.0                                //
//                                                                                //
// Unless required by applicable law or agreed to in writing, software            //
// distributed under the License is distributed on an "AS IS" BASIS,              //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.       //
// See the License for the specific language governing permissions and            //
// limitations under the License.                                                 //
//================================================================================//
//
//

#include <{header_name}>

{ccode_body}


"""


_CREATE_PROGRAM_TEMPLATE ='''
cl_program cy_create_{name}_program( cl_context context, cl_int *errcode_ret )
{{
    return clCreateProgramWithSource ( context, 1, {string_name}, {length}, errcode_ret);
}}
'''

_CREATE_KERNEL_TEMPLATE = '''
cl_kernel cy_create_{name}_kernel( cl_program program, cl_int *errcode_ret )
{{
    return clCreateKernel (program, "{name}", errcode_ret);
}}
'''

_CALL_KERNEL_TEMPLATE = '''
{func_defn}
{{
    cl_int err = CL_SUCCESS;
    
{set_kernel_args}

    err = clEnqueueNDRangeKernel( queue, kernel, 3, 0, global_work_size, local_work_size, num_events, wait, event);
    
    return err
}}

'''


class ExportCModule( object ):
    def __init__(self, modname ):
        self.modname = modname
        self.headername = "%s.h" %modname
        self.ccodename = "%s.c" %modname
#        self.header = StringIO( )
#        self.ccode = StringIO( )
        
        self.clfunctions = {}
        
    
        
    def CExport( self, **kwargs):
        self.clfunctions.update( kwargs )
    
    def create(self):
        
        body = []
        cbody = []
        static_strings = []
        for fnc_name, kernel in self.clfunctions.items():
            
            set_kernel_args =[]
            cdefs = []
            
            ss = '\\n" \\\n"'.join( kernel.source.splitlines( ) )
            
            static_strings.append(  kernel.source )
            
            for i,argname in enumerate(kernel.argnames):
                argt = kernel.argtypes[argname]
                if isinstance( argt, global_array_type ):
                    cdefs.append( 'cl_mem %s' %argname )
                    
                    set_kernel_args.append( '    err = clSetKernelArg( kernel, {i}, sizeof(cl_mem), &{name});'.format(i=i, name=argname) )
                    
                elif isinstance( argt, shared_array_type ):
                    set_kernel_args.append( '    err = clSetKernelArg( kernel, {i}, {size}, 0);'.format(i=i, size=argt.nbytes) )
                    
                else:
                    acdef = cltype.cdef( argt )
                    set_kernel_args.append( '    err = clSetKernelArg( kernel, {i}, sizeof({type}), &{name} );'.format( i=i, tyep=acdef, name=argname) )
                    cdefs.append( "%s %s" %( acdef ,argname ))
                    
            set_kernel_args = "\n    if (err != CL_SUCCESS) {return err;}\n\n".join( set_kernel_args ) + '\n    if (err != CL_SUCCESS) {return err;}\n'
            
            cdefs.append( "cl_int global_work_size[3]" )
            cdefs.append( "cl_int local_work_size[3]" )
            cdefs.append( "cl_kernel kernel" )
            cdefs.append( "cl_command_queue queue" )
            cdefs.append( "cl_uint num_events" )
            cdefs.append( "cl_event* wait" )
            cdefs.append( "cl_event* event" )
                    
            funcdefn = "cl_int {name}( {args} )".format( name=fnc_name,args=", ".join(cdefs) )
            
            body.append( funcdefn+";" )
            
            strname = '_cy_{name}_string'.format(name=fnc_name)
            lenname = '_cy_{name}_string_len'.format(name=fnc_name)
            cbody.append( 'static char {name}[] = "{text}";\n\n'.format( name=strname, text=ss ) )
            cbody.append('static unsigned int {name} = {i};'.format(name=lenname, i=len(kernel.source) ) )
            cbody.append( _CREATE_PROGRAM_TEMPLATE.format( name=fnc_name, string_name=strname, length=lenname ) )
            cbody.append( _CREATE_KERNEL_TEMPLATE.format( name=fnc_name ) )
            cbody.append( _CALL_KERNEL_TEMPLATE.format( func_defn=funcdefn,set_kernel_args=set_kernel_args ) )
                         
#            cbody.append( 'cl_int _cy_{name}_string[] = "{text}"'.format( name=fnc_name, text=ss ) )
                
            print fnc_name, kernel
            print kernel.argtypes
            
            print kernel.argnames
            print kernel.cdef( )
            pass
        
        header_body = "\n".join( body )
        
        ccode_body = "\n".join( cbody )
        
        
        
        header_string = _HEADER_STRING.format( header_body=header_body, MODNAME=self.modname.upper() , 
                                               ctime=time.ctime() )
        ccode_string = _CCODE_STRING.format( header_name=self.headername, ccode_body=ccode_body, 
                                             ctime=time.ctime() )
        
        header = open( self.headername ,'w')
        header.write( header_string )
        header.close( )

        ccode = open( self.ccodename ,'w')
        ccode.write( ccode_string )
        ccode.close( )

            
#        self.header_string
        
#        self.header.writelines( ['#endif _CLYTHER_%s_' %self.modname.upper(),
#                                 '',
#                                 ] )
    
